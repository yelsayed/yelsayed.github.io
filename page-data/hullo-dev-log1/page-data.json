{"componentChunkName":"component---src-templates-blog-post-js","path":"/hullo-dev-log1/","result":{"data":{"site":{"siteMetadata":{"title":"Yasser Codes","social":{"twitter":"ysr.sayed","instagram":"yeyeyesser","medium":"theyasser","email":"ysr.sayed@gmail.com"}}},"markdownRemark":{"id":"3818d5a3-0ed5-5488-a33b-790828970821","excerpt":"Background I came across this book called Writing an Interpreter in Go, which essentially is a long tutorial \nfor writing an interpreted programming language in…","html":"<h2>Background</h2>\n<p>I came across this book called <a href=\"https://interpreterbook.com/\">Writing an Interpreter in Go</a>, which essentially is a long tutorial\nfor writing an interpreted programming language in Golang.</p>\n<p>I’ve always wanted to write a programming language, and I’ve always wanted to learn Go. I thought this would be a fun\nthing to do in the morning before my work day starts. I also thought this would be a good time for me to get\nback into writing. I’ve been having terrible writer’s block since my article last year, as I feel everything\nthat I write is not of much worth and I’m riddled with low self esteem.</p>\n<p>So here we are. Don’t think too much just write about what you did (yes I’m talking to myself).</p>\n<h2>Interpreter</h2>\n<p>Let’s get to building the <code class=\"language-text\">hullo</code> programming language.</p>\n<h3>Language Features</h3>\n<p>The objective for me is to write a simple interpreted language in my own syntax that has all the basics of a C-type\nprogramming language. This language will have the following features:</p>\n<ul>\n<li><code class=\"language-text\">{ }</code>  to start and end a code block</li>\n<li><code class=\"language-text\">if</code>, <code class=\"language-text\">else</code> conditionals</li>\n<li><code class=\"language-text\">for</code> loop</li>\n<li><code class=\"language-text\">fn</code> function definitions and ability to call those definitions</li>\n<li><code class=\"language-text\">=</code> to assign</li>\n<li><code class=\"language-text\">;</code> to end statements</li>\n<li><code class=\"language-text\">+</code>, <code class=\"language-text\">-</code>, <code class=\"language-text\">/</code>, <code class=\"language-text\">*</code>, <code class=\"language-text\">&lt;</code>, <code class=\"language-text\">&gt;</code>, <code class=\"language-text\">!</code>, <code class=\"language-text\">==</code>, <code class=\"language-text\">!=</code> operators for arithmatic and comparison</li>\n<li><code class=\"language-text\">return</code> in order to exit functions</li>\n</ul>\n<p>Limitations:</p>\n<ul>\n<li>All variables and keywords be in ASCII</li>\n<li>No floats (at least for now)</li>\n</ul>\n<h2>Basic Structure of an Interpreter</h2>\n<p>According to Wikipedia:</p>\n<blockquote>\n<p>An interpreter is a computer program that directly executes instructions written in a programming or scripting\nlanguage, without requiring them previously to have been compiled into a machine language program.</p>\n</blockquote>\n<p>This is an apt description. The objective for an interpreter is to build a program that will take source code, make\nsense of it and then execute it. We would basically have to tokenize the code, and then create an abstract syntax tree\nthat we can execute.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Source Code -&gt; Tokens -&gt; Abstract Syntax Tree (AST) </code></pre></div>\n<p>An AST is a graph data-structure that would represent our code. We will get to the AST in later dev logs. In this dev\nlog we’re going to focus primarily on how we’re going to build the elements of that syntax tree.</p>\n<p>To transform the source code into tokens, we’ll have to build a Lexer, which will lexically analyze a code and\ntransform them into meaningful, easily categorizable data structures called tokens.</p>\n<h3>Lexer</h3>\n<p>My progress so far has been about building the Lexer, which is easier than you might think. I use one pointer and go\nthrough the code character by character until I find distinct keywords that would form a token.</p>\n<p>Let’s go through one example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This is a simple example to demonstrate how the lexer works, but in the future we’ll use more complicated examples.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//     ^</span></code></pre></div>\n<p>When a pointer hits a space it knows to do a lookup for the word let in the defined keywords. If it finds it, it\nwill create a token of type <code class=\"language-text\">token.LET</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//            ^</span></code></pre></div>\n<p>Similarly here, although “twelve” is not a defined keyword, meaning that it’s likely a variable name, so we can create\na token of type <code class=\"language-text\">token.IDENT</code> and literal value of <code class=\"language-text\">twelve</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//             ^</span></code></pre></div>\n<p>This character it encountered is a special character, we check to see if it’s followed by another ”=”, if so then we\ncreate <code class=\"language-text\">token.EQUALS</code> for ”==”, otherwise we create <code class=\"language-text\">token.ASSIGN</code> for ”=“.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//               ^</span></code></pre></div>\n<p>At this point we encountered a number, so we keep pushing the pointer until it doesn’t see numbers anymore in order to\nbuild the full number (12), then we create the token <code class=\"language-text\">token.INT</code> for the literal “12”.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Semicolon is a special character so we immediately create a token <code class=\"language-text\">token.SEMICOLON</code> with the literal <code class=\"language-text\">;</code>.</p>\n<p>Finally, we create a <code class=\"language-text\">token.EOF</code> to indicate that the code is done.</p>\n<h3>TDD</h3>\n<p>A nice thing about writing a program that parses strings and creates tokens is that it’s relatively easy to employ TDD.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> lexer\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n\t<span class=\"token string\">\"testing\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> NextTokenTest <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\texpectedType    token<span class=\"token punctuation\">.</span>TokenType\n\texpectedLiteral <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">runNextTokenTests</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">,</span> input <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> tests <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>NextTokenTest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">TestSymbols</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tinput <span class=\"token operator\">:=</span> <span class=\"token string\">`!-/*5&lt;>`</span>\n\ttests <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>NextTokenTest<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>BANG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"!\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>MINUS<span class=\"token punctuation\">,</span> <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>DIVIDE<span class=\"token punctuation\">,</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>MULTIPLY<span class=\"token punctuation\">,</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>INT<span class=\"token punctuation\">,</span> <span class=\"token string\">\"5\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>LT<span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>GT<span class=\"token punctuation\">,</span> <span class=\"token string\">\">\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span>token<span class=\"token punctuation\">.</span>EOF<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token function\">runNextTokenTests</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> input<span class=\"token punctuation\">,</span> tests<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Through out this process building the tests really helped with getting a good documentation on my progress.</p>\n<h3>Cherry on Top, a REPL!</h3>\n<p>A <code class=\"language-text\">REPL</code> stands for Read, Eval, Print, Loop and most languages have one. It’s very straightforward to write one, you\njust take the input line by line and pass it to the lexer. But this allows you to test quickly your program to see\nif it’s spitting out the correct tokens.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"> go run main.go                                                      <span class=\"token number\">16</span>:12:30\nHello yelsayed<span class=\"token operator\">!</span> This is the Hullo programming language<span class=\"token operator\">!</span>\nExecuting the REPL<span class=\"token operator\">!</span>\n<span class=\"token operator\">>></span>let twelve <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span>Type:LET Literal:let<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span>Type:IDENT Literal:twelve<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span>Type:<span class=\"token operator\">=</span> Literal:<span class=\"token operator\">=</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span>Type:INT Literal:12<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span>Type:<span class=\"token punctuation\">;</span> Literal:<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>So sexy! Next log will be about writing the parser, and how the parser will make sense of these tokens.</p>","frontmatter":{"title":"Hullo Programming Language - Dev Log 1","date":"February 21, 2024","description":"I'm currently building my own interpreted programming language with Go. This is the start of many dev logs."}},"previous":{"fields":{"slug":"/attendance/"},"frontmatter":{"title":"Building a Facial Recognition Attendance System in 30 days"}},"next":null},"pageContext":{"id":"3818d5a3-0ed5-5488-a33b-790828970821","previousPostId":"ad8bba10-3d06-5b98-81ac-720d41d0c06e","nextPostId":null}},"staticQueryHashes":["2841359383"]}